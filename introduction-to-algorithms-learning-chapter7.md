---
title: 算法导论研读与分析（七）
date: 2013-08-27 10:00:00
tags: 动态规划
author: maclaon
comments: false
---
# 动态规划
## 背景
动态规划与分治方法相似，都是通过组合子问题的解来求解原问题，两者之间的区别为：
+ 分治方法：将问题划分为互不相交的子问题，递归求解子问题，再将他们的解组合起来，求出原问题的解。
+ 动态规划：应用于子问题的重叠情况，即不同的子问题具有公共子子问题。

两者之间的区别是分治算法做了很多不必要的工作，它会反复地求解那些公共子问题，而动态规划对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算。适合于用动态规划法求解的问题，经**分解后得到的子问题往往不是互相独立的**（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）

> 动态规划算法通常用于**求解具有某种最优性质的问题**。在这类问题中，可能会有许多可行解,每一个解都对应于一个值，我们希望找到具有最优值的解，使用动态规划来解题只需要多项式时间复杂度。

<!--more-->

## 算法介绍
动态规划算法的4个步骤:
+ 构造一个最优解的结构特征
+ 递归地定义最优解的值
+ 计算法最优解的值，通常采用自底向上的方法
+ 利用计算出的信息构造一个最优解

> 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

### 步骤解说
动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。
>  初始状态→决策１→决策２→…→决策ｎ→结束状态

+ 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解
+ 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
+ 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
+ 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。


### 应用场景（特点）
适用动态规划的问题必须满足:
+ 最优化原理（最优子结构性质）：每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，而不管之前这个状态是如何得到的。
+ 无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。
+ 子问题的重叠性：动态规划将原来具有**指数级时间复杂度**的搜索算法改进成了具有**多项式时间复杂度**的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。

### 本质
> + 对问题状态的定义和状态转移方程的定义。通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推(或者说分治)的方式去解决。如何拆分问题才是动态规划本质核心。
> + 对当前问题状态的定义和状态转移方程定义后，都可以用数学表达式对上述的问题求解进行定义。
> + 状态的定义非常重要，可能是一维，二维或者多维的。

状态可以是多种多样的，简单的就是一维情况，复杂的是多维情况，具体的问题需要具体分析，脑洞要大!状态与状态之间的关系式叫状态转移方程。寻找看问题的角度才是最本质的特点。

### 实现方法
+ 带备忘的自顶向下法: 仍然按照自然的递归形式编写过程，但过程会保存每个子问题的解(通常保存在一个数组或散列表中)。当需要一个子问题的解时，过程首先检查是否保存过此解。
+ 自底向上法: 需要恰当**定义子问题“规模”**的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。将子问题按规模排序，由小到大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它(也是第一次遇到它)时，它的所有前提子问题都已经求解完成。

## 应用场景
+ [最大连续子数组和](http://shieldme.cn/2013/06/23/introduction-to-algorithms-learning-chapter2/)
+ [最长公共子序列]()


