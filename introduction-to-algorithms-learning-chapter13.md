---
title: 算法导论研读与分析（十三）
date: 2013-10-08 10:00:00
tags: 图，最小生成树
author: maclaon
comments: false
---
# 最小生成树
在电子电路设计中，常常需要将多个组件的针脚连接在一起，要连接$$n$$个针脚，可以使用$$n-1$$跟连线，每根连线连接两个针脚，希望所使用的连线长度最短。模型转化：在一个连通的带权的无向图中，选取一颗生成树，使树所有边上的权值加起来最小，并且能够连接所有节点。
## 算法
### Kruskal算法
>  基本思想：设无向连通网为$$G＝(V, E)$$，令G的最小生成树为$$T＝(U, TE)$$，其初态为$$U＝V，TE＝\{\}$$，然后，按照边的权值由小到大的顺序，考察G的边集E中的各条边。若被考察的边的两个顶点属于$$T$$的两个不同的连通分量，则将此边作为最小生成树的边加入到$$T$$中，同时把两个连通分量连接为一个连通分量；若被考察边的两个顶点属于同一个连通分量，则舍去此边，以免造成回路，如此下去，当T中的连通分量个数为1时，此连通分量便为$$G$$的一棵最小生成树。

<!--more-->

### 图解
![](http://pic002.cnblogs.com/images/2010/202684/2010120121113324.png)

## Prim算法
> 基本思想：设$$G=(V, E)$$是具有$$n$$个顶点的连通网，$$T=(U,TE)$$是$$G$$的最小生成树,$$T$$的初始状态为$$U={u0},(u_0\in V),TE=\{\}$$，重复执行下述操作：在所有$$u\in U, v\in (V-U)$$的边中找一条代价最小的边$$(u,v)$$并入集合$$TE$$，同时$$v$$并入$$U$$，直至$$U=V$$。即:
> + 从连通网络$$G=\{V,E\}中的某一顶点$$u_0$$出发，选择与它关联的具有最小权值的边$$(u_0, v)$$，将其顶点加入到生成树的顶点集合$$U$$中.
> + 以后每一步从一个顶点在$$U$$中，而另一个顶点不在$$U$$中的各条边中选择权值最小的边$$(u, v)$$,把它的顶点加入到集合$$U$$中。如此继续下去，直到网络中的所有顶点都加入到生成树顶点集合$$U$$中为止。

### 图解
![](http://pic002.cnblogs.com/images/2010/202684/2010120120450542.png)

![](http://pic002.cnblogs.com/images/2010/202684/2010120120455028.png)

# 单源最短路径
其中最小生成树是没有方向的，单源最短路径是有方向的。

> 问题描述: 给定一个带权有向图$$G=(V,E)$$，其中每条边的权是一个非负实数。另外，还给定$$V$$中的一个顶点，称为源。现在我们要计算从源到所有其他各顶点的最短路径长度。这里的长度是指路上各边权之和。

## Dijkstra算法
> Dijkstra(迪杰斯特拉)算法是典型的最短路径路由算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。

### 基本思想
设置顶点集合S并不断地作贪心选择来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。

### 图例
如下所示的无向图:
![](http://pic002.cnblogs.com/images/2012/426620/2012073019593375.jpg)

执行步骤如下:
![](http://pic002.cnblogs.com/images/2012/426620/2012073020014941.jpg)

# 所有节点对的最短路径
## Floyd-Warshall算法
> Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点$$i$$到点$$j$$的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）从任意节点$$i$$到任意节点$$j$$的最短路径不外乎2种可能，1是直接从$$i$$到$$j$$，2是从$$i$$经过若干个节点$$k$$到$$j$$。所以，我们假设$$Dis(i,j)$$为节点$$u$$到节点$$v$$的最短路径的距离，对于每一个节点$$k$$，我们检查$$Dis(i,k) + Dis(k,j) < Dis(i,j)$$是否成立，如果成立，证明从$$i$$到$$k$$再到$$j$$的路径比$$i$$直接到$$j$$的路径短，我们便设置$$Dis(i,j) = Dis(i,k) + Dis(k,j)$$，这样一来，当我们遍历完所有节点$$k$$，$$Dis(i,j)$$中记录的便是$$i$$到$$j$$的最短路径的距离。

### 基本思想
+ 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。
+ 对于每一对顶点$$u$$和$$v$$，看看是否存在一个顶点$$w$$使得从$$u$$到$$w$$再到$$v$$比己知的路径更短。如果是更新它。

Floyd算法过程矩阵的计算----十字交叉法

### 图例

![](http://pic002.cnblogs.com/images/2012/426620/2012073109403649.gif)

![](http://pic002.cnblogs.com/images/2012/426620/2012073109460084.jpg)

![](http://pic002.cnblogs.com/images/2012/426620/2012073109453085.jpg)

![](http://pic002.cnblogs.com/images/2012/426620/2012073109463549.jpg)


