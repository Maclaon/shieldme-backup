---
title: 算法导论研读与分析--分治算法总结
date: 2013-08-11 10:00:00
tags: 分治算法，算法导论，算法分析，数据结构，第三版
author: maclaon
comments: false
---
## 分治算法
因为分治算法大而化小，小而解决的思路，贯穿整个算法导论书籍，特别开一章来专门研读与分析分治算法的应用场景和应用原理，后续会根据整体性学习的思路，来不断的建立分治算法的模型，结构和对应的联系，通过拓展，修正和应用多个角度来丰富分治算法的理论。
### 概念
> 将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。**而函数本身的符号可以作为分治算法中子问题的解，可以很好地建立模型，但是每个模型都是可以按照如下来重复进行的。**

+ **分解**原问题为若干子问题，这些子问题都是原问题规模较小的实例，所有子问题加起来等于原问题
+ **解决**这些子问题，递归地求解各个子问题。如果子问题的规模足够的小，则直接给出答案
+ **合并**这些子问题的解成为原问题的解

<!--more-->
### 模型
+ 数据存储结构本身: 数组
+ 解决方案本身: 这部分需要抽象化，可能根据数据结构本身，或者策略本身等其他因素
+ 数学模型: 已经归纳成数学表达式的，触类旁通下，那么也可以把解决方案归纳成数学表达式

### 疑问
+ 因为分治算法是个递归解，那么分解到什么时候才不能分解，这些有哪些基本原则?

> 1. 可以看出如果分解的子问题不是原问题规模更小的实例，这里的实例就是当前的分解下来的**子问题能否继续按照分治的三个步骤再继续组合**，从最大连续子数组的和中可以看出，左边数组和右边数组都是可以按照分解的套路继续分解，因为它们没有啥限制条件，左右子数组和原来数组没区别，但是跨越中点的子数组就是有限制的。
> 2. 如果分解的子问题比较多或者分解的场景不够精简的话，那么模型本身可能就是错误的，一般情况下，子问题存在3、4个的时候就说明分解的很到位。

+ 什么样的情况下才去实现分治算法中各个问题的解(也就是写代码)?

> 分治算法中的子问题是可以用本身函数的**递归调用函数解决**，那么剩下的需要实现的就是无法继续进行分解的子问题。

+ 编写代码的时候是否有需要重复考虑上述的场景，考虑其中的因素？
> 一直很困惑，再求解子问题的时候，又会重复陷入原问题的干扰，再求解子问题的时候，专注于解决子问题需要求解的场景，因为这个是**分解后留下的问题，是一个独立的与原问题又有依存的问题，本身是独立性的**，多个独立性的组合构成了原问题的解。

+ 分治算法中**递归子问题**有什么特性（能够套用递归函数式的子问题的解）？
> 规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的,本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。

+ 分治算法的各个子问题有什么特性（所有子问题解合并后变成原问题的解的子问题）？
> 子问题肯定需要规模更小的递归子问题来解决，同样除了递归子问题以外的还需要非递归子问题的存在，他们共同组成了原问题的解，**必然有规模更小的递归子问题，也必然没有递归子问题的存在，递归子问题讨论函数式解决，非递归子问题直接应对具体情况进行处理**。
