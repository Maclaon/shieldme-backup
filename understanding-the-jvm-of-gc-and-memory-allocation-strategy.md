---
title: 深入理解JVM虚拟机之垃圾回收器与内存分配策略
date: 2015-07-05 10:00:00
tags: 深入理解JVM虚拟机，垃圾回收器，内存分配策略
author: maclaon
comments: false
---
# 垃圾回收器与内存分配策略
垃圾回收器需要做的事情如下:
> + 哪些内存需要回收?
> + 什么时候回收?
> + 如何回收?

## 对象已经死了吗?
垃圾回收器主要的作用是对没有内存分配的对象进行回收，前一章节[Java内存区域与内存溢出异常](http://shieldme.cn/2015/07/01/understanding-the-jvm-of-memory-district-and-oom/)中明确指出**堆所在的区域主要是垃圾回收器作用（除此之外方法区的常量和类的卸载也是区域，但是频率很低）**的地方。目前判断Java对象是否已经不再使用的时候，主要有以下两种方式:
> + 引用计数
> + 可达性分析(GC Roots链)

<!--more-->

![](http://oh8mi0yav.bkt.clouddn.com/the-method-to-check-object-live-or-not.png)

### 引用计数
引用计数主要是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时计数器值减1。
#### 优缺点
> + 实现简单，判断效率很高
> + 无法解决寻欢引用的问题

### 可达性分析
通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径称为引用链，当一个对象到"GC Roots"没有引用链的时候，则证明此对象是不可用的。Java中作为GC Roots的对象有以下几种:
> + 虚拟机栈(栈帧中的本地变量表)中所引用的对象
> + 方法区中类静态属性引用的对象
> 方法区中常量引用的对象
> 本地方法栈中JNI引用的对象

## 生存还是死亡
即使在可达性分析算法中不可达对象，也并非是"非死不可"，暂时属于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次比较过程。同时对于引用的强弱的关系，可以有低到高的进行。

## 回收方法区
方法区中的垃圾回收一般“性价比”比较低: 在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般回收$$70% ~ 90%$$的空间，而永久代的垃圾收集效率远低于此。

### 方法区的回收内容
方法取得永久代垃圾回收器主要回收两部分: 废弃的常量和无用的类。回收废弃常量与回收Java中堆的对象非常类似，而判定一个类是否是“无用的类”的条件就比较苛刻，必须满足如下的三个条件：
> + 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
> + 加载该类的`ClassLoader`已经被回收
> + 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成Jsp以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 垃圾收集算法
标记清除算法是基于上述的对象是否已经消亡的基础上进行的对内存对象收集的算法，目前主流的收集方式主要有以下三个点:
> + 标记-清除算法
> + 复制算法
> + 标记-整理算法
> + 分代收集算法

### 标记-清除
`Mark Sweep`是最基本的算法，算法分为两个阶段: 标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。

![](https://sfault-image.b0.upaiyun.com/250/335/2503350814-56f154684b8fc)

#### 优缺点
> 优点: 简单，便于实现
> 缺点: 效率问题，标记和清除两个过程的效率都不高；另一个空间问题，标记清除之后会产生大量的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![](http://static.oschina.net/uploads/img/201303/18092408_nT2F.jpg)

### 复制算法
为了解决效率问题，一种称为"复制"的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还在存活着的对象复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。

![](https://sfault-image.b0.upaiyun.com/353/177/353177941-56f1544c5f3de)

#### 优缺点
> 优点: 解决上述的内存碎片的问题
> 缺点: 内存浪费比较严重，按照$$1:1$$的划分有$$50%$$未被利用。

**现在的商业虚拟机都采用这种收集算法来回收新生代**，IBM公司专门研究表明，新生代中的对象$$98%$$是朝生即死的，所以并不需要按照$$1:1$$的比例来划分内存空间，而将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。Hotspot虚拟机中Eden和Survivor按照$$8:1$$。

![](http://img.blog.csdn.net/20160514223619547)

内存分配担保类似于银行借款，如果信誉良好，在$$98%$$的情况下都按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账号扣钱，那银行就认为没有风险。内存分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象就直接通过分配担保机制进入老年代。


![](http://static.oschina.net/uploads/img/201303/18092409_AaxY.jpg)

### 标记-整理算法
复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费$$50%$$的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都$$100%$$存活的极端情况，所以在**老年代中一般不能直接选用这种算法**。

> 根据老年代的特点，标记-整理算法，标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 流程
+ 标记
	与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记
+ 整理
	移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段
	
#### 优缺点
标记/整理算法唯一的缺点就是效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。

### 分代收集算法
垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，这样的话新生代中，**每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。而**老年代中因为对象存活率较高，没有额外空间对它进行分配担保**，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。

## 总结
![](http://oh8mi0yav.bkt.clouddn.com/alogrithm-of-gc.png)

