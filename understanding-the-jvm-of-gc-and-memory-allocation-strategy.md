---
title: 深入理解JVM虚拟机之垃圾回收器与内存分配策略
date: 2015-07-05 10:00:00
tags: 深入理解JVM虚拟机，垃圾回收器，内存分配策略
author: maclaon
comments: false
---
# 垃圾回收器与内存分配策略
垃圾回收器需要做的事情如下:
> + 哪些内存需要回收?
> + 什么时候回收?
> + 如何回收?

## 对象已经死了吗?
垃圾回收器主要的作用是对没有内存分配的对象进行回收，前一章节[Java内存区域与内存溢出异常](http://shieldme.cn/2015/07/01/understanding-the-jvm-of-memory-district-and-oom/)中明确指出**堆所在的区域主要是垃圾回收器作用（除此之外方法区的常量和类的卸载也是区域，但是频率很低）**的地方。目前判断Java对象是否已经不再使用的时候，主要有以下两种方式:
> + 引用计数
> + 可达性分析(GC Roots链)

<!--more-->
### 引用计数
引用计数主要是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时计数器值减1。
#### 优缺点
> + 实现简单，判断效率很高
> + 无法解决寻欢引用的问题

### 可达性分析
通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径称为引用链，当一个对象到"GC Roots"没有引用链的时候，则证明此对象是不可用的。Java中作为GC Roots的对象有以下几种:
> + 虚拟机栈(栈帧中的本地变量表)中所引用的对象
> + 方法区中类静态属性引用的对象
> 方法区中常量引用的对象
> 本地方法栈中JNI引用的对象

## 生存还是死亡
即使在可达性分析算法中不可达对象，也并非是"非死不可"，暂时属于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次比较过程。同时对于引用的强弱的关系，可以有低到高的进行。

## 回收方法区
方法区中的垃圾回收一般“性价比”比较低: 在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般回收$$70% ~ 90%$$的空间，而永久代的垃圾收集效率远低于此。

### 方法区的回收内容
方法取得永久代垃圾回收器主要回收两部分: 废弃的常量和无用的类。回收废弃常量与回收Java中堆的对象非常类似，而判定一个类是否是“无用的类”的条件就比较苛刻，必须满足如下的三个条件：
> + 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
> + 加载该类的`ClassLoader`已经被回收
> + 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成Jsp以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 垃圾收集算法
标记清除算法是基于上述的对象是否已经消亡的基础上进行的对内存对象收集的算法，目前主流的收集方式主要有以下三个点:
> + 标记-清除算法
> + 复制算法
> + 标记-整理算法
> + 分代收集算法

### 标记-清除
`Mark Sweep`是最基本的算法，算法分为两个阶段: 标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。

![](https://sfault-image.b0.upaiyun.com/250/335/2503350814-56f154684b8fc)

#### 优缺点
> 优点: 简单，便于实现
> 缺点: 效率问题，标记和清除两个过程的效率都不高；另一个空间问题，标记清除之后会产生大量的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![](http://static.oschina.net/uploads/img/201303/18092408_nT2F.jpg)

### 复制算法
为了解决效率问题，一种称为"复制"的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还在存活着的对象复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。

![](https://sfault-image.b0.upaiyun.com/353/177/353177941-56f1544c5f3de)

#### 优缺点
> 优点: 解决上述的内存碎片的问题
> 缺点: 内存浪费比较严重，按照$$1:1$$的划分有$$50%$$未被利用。

现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门研究表明，新生代中的对象$$98%$$是朝生即死的，所以并不需要按照$$1:1$$的比例来划分内存空间，而将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。Hotspot虚拟机中Eden和Survivor按照$$8:1$$。

内存分配担保类似于银行借款，如果信誉良好，在$$98%$$的情况下都按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账号扣钱，那银行就认为没有风险。内存分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象就直接通过分配担保机制进入老年代。


![](http://static.oschina.net/uploads/img/201303/18092409_AaxY.jpg)
