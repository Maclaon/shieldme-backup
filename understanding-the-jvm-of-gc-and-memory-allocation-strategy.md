---
title: 深入理解JVM虚拟机之垃圾回收器与内存分配策略
date: 2015-07-05 10:00:00
tags: 深入理解JVM虚拟机，垃圾回收器，内存分配策略
author: maclaon
comments: false
---
# 垃圾回收器与内存分配策略
垃圾回收器需要做的事情如下:
> + 哪些内存需要回收?
> + 什么时候回收?
> + 如何回收?

## 对象已经死了吗?
垃圾回收器主要的作用是对没有内存分配的对象进行回收，前一章节[Java内存区域与内存溢出异常](http://shieldme.cn/2015/07/01/understanding-the-jvm-of-memory-district-and-oom/)中明确指出**堆所在的区域主要是垃圾回收器作用（除此之外方法区的常量和类的卸载也是区域，但是频率很低）**的地方。目前判断Java对象是否已经不再使用的时候，主要有以下两种方式:
> + 引用计数
> + 可达性分析(GC Roots链)

<!--more-->
### 引用计数
引用计数主要是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时计数器值减1。
#### 优缺点
> + 实现简单，判断效率很高
> + 无法解决寻欢引用的问题

### 可达性分析
通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径称为引用链，当一个对象到"GC Roots"没有引用链的时候，则证明此对象是不可用的。Java中作为GC Roots的对象有以下几种:
> + 虚拟机栈(栈帧中的本地变量表)中所引用的对象
> + 方法区中类静态属性引用的对象
> 方法区中常量引用的对象
> 本地方法栈中JNI引用的对象

## 生存还是死亡
即使在可达性分析算法中不可达对象，也并非是"非死不可"，暂时属于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次比较过程。同时对于引用的强弱的关系，可以有低到高的进行。

## 回收方法区
方法区中的垃圾回收一般“性价比”比较低: 在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般回收$$70% ~ 90%$$的空间，而永久代的垃圾收集效率远低于此。

### 方法区的回收内容
方法取得永久代垃圾回收器主要回收两部分: 废弃的常量和无用的类。回收废弃常量与回收Java中堆的对象非常类似，而判定一个类是否是“无用的类”的条件就比较苛刻，必须满足如下的三个条件：
> + 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
> + 加载该类的`ClassLoader`已经被回收
> + 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成Jsp以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。