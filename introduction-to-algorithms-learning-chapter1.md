---
title: 算法导论研读与分析（一）
date: 2013-05-12 10:00:00
tags: 算法导论，算法分析，数据结构，第三版
author: maclaon
comments: false
---
## 算法基础
### 插入排序
输入：n个数的一个序列
$$\langle a_1,a_2,...,a_n\rangle$$
输出: 输入序列的一个排列
$$\langle a^1,a^2,...,a^n\rangle$$
满足
$$a^1\leq a^2,...,\leq a^n$$
<!--more-->
数据结构存储数据的数组$$a[1..n]$$

算法的思路（**思路要清晰，步骤按照逻辑来，模型建立好**):
+ 拿出当前要比较的值，与先前已经排过序的子序列，逆序进行比较，直到数组结束
+ 当需要比较的值大于当前比较的值的时候停止比较，交换两者之间的位置关系
+ 如果值小于当前有序序列的值的时候，交换两者之间的值。

```python
for(int i = 1; i < a.length; i++){				
	int needSortValue = a[i];
	int compareIndex = i - 1;
	while(compareIndex > 0 && needSortValue < a[compareIndex]){
		a[compareIndex + 1] = a[compareIndex];
		compareIndex = compareIndex - 1;
	}
	a[compareIndex + 1] = needSortValue 
}
```
算法分析思想：**对上述的代码执行流程做时间消耗的数学模型构建**，假设$$n=a.length$$

+ 第一行: 以`for`循环的执行语义来看，执行次数为：$$a.length - 1 + 1 = n$$
+ 第二、三、八行: 因`for`循环中`i`会额外自增到`i = a.length`时，不满足条件退出，所以该行执行次数为: $$n-1$$
+ 第四行: 该行执行的次数不明确，会因为序列原始的排列的状况受到影响(指出受影响的因子，写出泛函因子)，假设该行每次执行的次数为$$t_j$$表示每次执行到j时，该行所需要执行的次数，该行在整个`for`循环中执行了$$\sum_{j=2}^{n}{t_j}$$
+ 第五、六行: 类似于`for`循环，该执行次数为$$t_j-1$$整个循环一共执行的次数为:$$\sum_{j=2}^{n}{t_j-1}$$

可以得出整个事件消耗为:
$$T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\sum_{j=2}^{n}t_j+c_5\sum_{j=2}^{n}(t_j-1) + c_6\sum_{j=2}^{n}(t_j-1) + c_7(n-1)$$

**最坏的情况下(后续我们都会以最坏的情况下来分析算法，因为它是系统的极限)，就是数组的逆序$$t_j$$的次数是不可控的，那么从数学角度来看，最大值和最小值就是从这里诞生起来的，所以数学模型的建立尤其重要**
$$T(n)=an^2+bn+c\approx\Theta(n^2)$$

> 插入排序非常适合小规模输入，是一种非常快的原址排序算法。

### 整体性学习的关联
> 插入排序和玩扑克牌是一致，每次抓取一张牌将其插入到扑克牌左边的牌中，只不过有时候我们是从左边向右边依次插入，上述的插入排序的算法是从右边最大的进行插入，两者在结果上是一致的，在算法时间复杂度上也是一致的，比较交换，直到比较的数据大于当前索引中的数据。其中模型是玩扑克牌。
> 算法分析的主要思想是建立每个代码元语的消耗时间，对于不确定的数据暂时用数学符号先代替，后续专门对这些用例场景进行分析，符合分而治之的想法。模型是数学理论。


##设计算法
许多有用的算法在结构上是**递归**的: 算法一次或多次递归调用其自身以解决紧密相连的若干子问题，遵循分治法的思想:
> 将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

### 递归说明
递归的解决方法具体的应用的过程中可能主要是从解决方案上向递归去解决，它可能在形式上如下：
+ 数据结构本身是递归的
+ 解决方案是递归的
+ 数学表达式的方式

分治算法每层递归都有三个步骤：
+ **分解**原问题为若干子问题，这些子问题都是原问题规模较小的实例，所有子问题加起来等于原问题
+ **解决**这些子问题，递归地求解各个子问题。如果子问题的规模足够的小，则直接给出答案
+ **合并**这些子问题的解成为原问题的解

### 归并排序
归并排序算法遵循上述的分治模式。操作如下:
+ 分解: 分解待排序的$$n$$个元素的序列成各具$$n/2$$个元素的两个子序列。
+ 解决: 使用归并排序递归的排序两个子序列。
+ 合并: 合并两个已经排序的子序列以产生已排序的结果。

>归并排序在已经排好序的数据中，不断的拿出数据进行比较，如果当前的$$A$$中拿出的数据小于$$B$$中拿出的数据，将$$A$$中的数据放入新的排序序列中，继续拿$$A$$中的下一个元素与$$B$$中的元素进行比较，$$A$$和$$B$$的位置可以对等的调换，直到其中某个结果集的数据为空。需要占用额外的$$\Theta(n)$$的存储空间。

归并排序可以解决$$top(n)$$的问题，从多个堆排序的过程中拿出数据进行比较，**引申出$$top(n)$$问题**。

![](http://img.blog.csdn.net/20150606133629136)
### 整体性学习的关联
归并算法(递归)中有个很重要的一点就是，可以用**递归本身代表一部分解**，这个解可以带到解决方案中，数据结构中或者数学表达式中，如何应用需要按照上述的**分治算法的步骤**来拆解。归并的实际上是不断的从两堆扑克牌中拿出两张牌进行比较，较小的先放入手中，然后从较小的那一堆中继续抓牌，跟另外一堆中先前留下的牌进行比较，重复上述动作直到某个牌堆为空，模型是任然是打牌。

### 冒泡排序
交换排序的基本思想是，比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两个记录，这样将键值较小的记录向序列前部移动，键值较大的记录向序列后部移动。首先将第一个记录的键值和第二个键值进行比较，若为逆序，即$$R[1].key$$大于$$R[2].key$$，则将这两个记录交换，然后继续比较第二个和第三个记录的键值，依此类推，直到完成第$$n-1$$个记录和第$$n$$个记录的键值比较交换为止，上述过程称为第一趟起泡，其结果使键值最大的记录移到了第$$n$$个位置上，然后再进行第二趟起泡，即对前$$n-1$$个记录进行同样的操作，其结果是次大键值的记录安置在第$$n-1$$个位置上，重复上面的过程，当在一趟起泡过程中没有进行记录交换的操作时，整个排序过程终止。
![](http://img.blog.csdn.net/20150606135803929)